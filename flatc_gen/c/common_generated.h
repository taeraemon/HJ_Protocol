// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_HJPROTOCOL_H_
#define FLATBUFFERS_GENERATED_COMMON_HJPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace HJProtocol {

/// 운용 모드 (Operation Mode)
enum class OperationMode : int8_t {
  UNKNOWN = 0,
  INIT = 1,
  IDLE = 2,
  DIAG = 3,
  ARMED = 4,
  FLIGHT = 5,
  KILL = 6,
  RECOVERY = 7,
  MIN = UNKNOWN,
  MAX = RECOVERY
};

inline const OperationMode (&EnumValuesOperationMode())[8] {
  static const OperationMode values[] = {
    OperationMode::UNKNOWN,
    OperationMode::INIT,
    OperationMode::IDLE,
    OperationMode::DIAG,
    OperationMode::ARMED,
    OperationMode::FLIGHT,
    OperationMode::KILL,
    OperationMode::RECOVERY
  };
  return values;
}

inline const char * const *EnumNamesOperationMode() {
  static const char * const names[9] = {
    "UNKNOWN",
    "INIT",
    "IDLE",
    "DIAG",
    "ARMED",
    "FLIGHT",
    "KILL",
    "RECOVERY",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperationMode(OperationMode e) {
  if (::flatbuffers::IsOutRange(e, OperationMode::UNKNOWN, OperationMode::RECOVERY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperationMode()[index];
}

/// 항법 정렬 상태 (Navigation Status)
enum class NavStatus : int8_t {
  UNKNOWN = 0,
  UNALIGNED = 1,
  COARSE_ALIGN = 2,
  FINE_ALIGN = 3,
  ALIGNED = 4,
  MIN = UNKNOWN,
  MAX = ALIGNED
};

inline const NavStatus (&EnumValuesNavStatus())[5] {
  static const NavStatus values[] = {
    NavStatus::UNKNOWN,
    NavStatus::UNALIGNED,
    NavStatus::COARSE_ALIGN,
    NavStatus::FINE_ALIGN,
    NavStatus::ALIGNED
  };
  return values;
}

inline const char * const *EnumNamesNavStatus() {
  static const char * const names[6] = {
    "UNKNOWN",
    "UNALIGNED",
    "COARSE_ALIGN",
    "FINE_ALIGN",
    "ALIGNED",
    nullptr
  };
  return names;
}

inline const char *EnumNameNavStatus(NavStatus e) {
  if (::flatbuffers::IsOutRange(e, NavStatus::UNKNOWN, NavStatus::ALIGNED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNavStatus()[index];
}

/// 고정 배열 크기 정의 (enum 분리 방식)
enum class MaxSv : uint16_t {
  LEN = 8,
  MIN = LEN,
  MAX = LEN
};

inline const MaxSv (&EnumValuesMaxSv())[1] {
  static const MaxSv values[] = {
    MaxSv::LEN
  };
  return values;
}

inline const char * const *EnumNamesMaxSv() {
  static const char * const names[2] = {
    "LEN",
    nullptr
  };
  return names;
}

inline const char *EnumNameMaxSv(MaxSv e) {
  if (::flatbuffers::IsOutRange(e, MaxSv::LEN, MaxSv::LEN)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(MaxSv::LEN);
  return EnumNamesMaxSv()[index];
}

enum class MaxPt : uint16_t {
  LEN = 12,
  MIN = LEN,
  MAX = LEN
};

inline const MaxPt (&EnumValuesMaxPt())[1] {
  static const MaxPt values[] = {
    MaxPt::LEN
  };
  return values;
}

inline const char * const *EnumNamesMaxPt() {
  static const char * const names[2] = {
    "LEN",
    nullptr
  };
  return names;
}

inline const char *EnumNameMaxPt(MaxPt e) {
  if (::flatbuffers::IsOutRange(e, MaxPt::LEN, MaxPt::LEN)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(MaxPt::LEN);
  return EnumNamesMaxPt()[index];
}

enum class MaxTc : uint16_t {
  LEN = 10,
  MIN = LEN,
  MAX = LEN
};

inline const MaxTc (&EnumValuesMaxTc())[1] {
  static const MaxTc values[] = {
    MaxTc::LEN
  };
  return values;
}

inline const char * const *EnumNamesMaxTc() {
  static const char * const names[2] = {
    "LEN",
    nullptr
  };
  return names;
}

inline const char *EnumNameMaxTc(MaxTc e) {
  if (::flatbuffers::IsOutRange(e, MaxTc::LEN, MaxTc::LEN)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(MaxTc::LEN);
  return EnumNamesMaxTc()[index];
}

}  // namespace HJProtocol

#endif  // FLATBUFFERS_GENERATED_COMMON_HJPROTOCOL_H_
