// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TELEMETRY_HJPROTOCOL_H_
#define FLATBUFFERS_GENERATED_TELEMETRY_HJPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace HJProtocol {

struct State;
struct StateBuilder;
struct StateT;

struct NAV;
struct NAVBuilder;
struct NAVT;

struct IMU;
struct IMUBuilder;
struct IMUT;

struct GPS;
struct GPSBuilder;
struct GPST;

struct Telemetry;
struct TelemetryBuilder;
struct TelemetryT;

struct StateT : public ::flatbuffers::NativeTable {
  typedef State TableType;
  uint64_t boot_time = 0;
  uint64_t mode_time = 0;
  HJProtocol::OperationMode mode = HJProtocol::OperationMode::UNKNOWN;
  int32_t countdown = 0;
  uint32_t warn_code = 0;
  uint32_t error_code = 0;
  float voltage = 0.0f;
  float current = 0.0f;
};

struct State FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateT NativeTableType;
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOOT_TIME = 4,
    VT_MODE_TIME = 6,
    VT_MODE = 8,
    VT_COUNTDOWN = 10,
    VT_WARN_CODE = 12,
    VT_ERROR_CODE = 14,
    VT_VOLTAGE = 16,
    VT_CURRENT = 18
  };
  uint64_t boot_time() const {
    return GetField<uint64_t>(VT_BOOT_TIME, 0);
  }
  uint64_t mode_time() const {
    return GetField<uint64_t>(VT_MODE_TIME, 0);
  }
  HJProtocol::OperationMode mode() const {
    return static_cast<HJProtocol::OperationMode>(GetField<int8_t>(VT_MODE, 0));
  }
  int32_t countdown() const {
    return GetField<int32_t>(VT_COUNTDOWN, 0);
  }
  uint32_t warn_code() const {
    return GetField<uint32_t>(VT_WARN_CODE, 0);
  }
  uint32_t error_code() const {
    return GetField<uint32_t>(VT_ERROR_CODE, 0);
  }
  float voltage() const {
    return GetField<float>(VT_VOLTAGE, 0.0f);
  }
  float current() const {
    return GetField<float>(VT_CURRENT, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BOOT_TIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_MODE_TIME, 8) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           VerifyField<int32_t>(verifier, VT_COUNTDOWN, 4) &&
           VerifyField<uint32_t>(verifier, VT_WARN_CODE, 4) &&
           VerifyField<uint32_t>(verifier, VT_ERROR_CODE, 4) &&
           VerifyField<float>(verifier, VT_VOLTAGE, 4) &&
           VerifyField<float>(verifier, VT_CURRENT, 4) &&
           verifier.EndTable();
  }
  StateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<State> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateBuilder {
  typedef State Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_boot_time(uint64_t boot_time) {
    fbb_.AddElement<uint64_t>(State::VT_BOOT_TIME, boot_time, 0);
  }
  void add_mode_time(uint64_t mode_time) {
    fbb_.AddElement<uint64_t>(State::VT_MODE_TIME, mode_time, 0);
  }
  void add_mode(HJProtocol::OperationMode mode) {
    fbb_.AddElement<int8_t>(State::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_countdown(int32_t countdown) {
    fbb_.AddElement<int32_t>(State::VT_COUNTDOWN, countdown, 0);
  }
  void add_warn_code(uint32_t warn_code) {
    fbb_.AddElement<uint32_t>(State::VT_WARN_CODE, warn_code, 0);
  }
  void add_error_code(uint32_t error_code) {
    fbb_.AddElement<uint32_t>(State::VT_ERROR_CODE, error_code, 0);
  }
  void add_voltage(float voltage) {
    fbb_.AddElement<float>(State::VT_VOLTAGE, voltage, 0.0f);
  }
  void add_current(float current) {
    fbb_.AddElement<float>(State::VT_CURRENT, current, 0.0f);
  }
  explicit StateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<State>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<State> CreateState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t boot_time = 0,
    uint64_t mode_time = 0,
    HJProtocol::OperationMode mode = HJProtocol::OperationMode::UNKNOWN,
    int32_t countdown = 0,
    uint32_t warn_code = 0,
    uint32_t error_code = 0,
    float voltage = 0.0f,
    float current = 0.0f) {
  StateBuilder builder_(_fbb);
  builder_.add_mode_time(mode_time);
  builder_.add_boot_time(boot_time);
  builder_.add_current(current);
  builder_.add_voltage(voltage);
  builder_.add_error_code(error_code);
  builder_.add_warn_code(warn_code);
  builder_.add_countdown(countdown);
  builder_.add_mode(mode);
  return builder_.Finish();
}

::flatbuffers::Offset<State> CreateState(::flatbuffers::FlatBufferBuilder &_fbb, const StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NAVT : public ::flatbuffers::NativeTable {
  typedef NAV TableType;
  HJProtocol::NavStatus nav_status = HJProtocol::NavStatus::UNKNOWN;
  float nav_roll = 0.0f;
  float nav_pitch = 0.0f;
  float nav_yaw = 0.0f;
  double nav_lat = 0.0;
  double nav_lon = 0.0;
  float nav_alt = 0.0f;
  float nav_qua0 = 0.0f;
  float nav_qua1 = 0.0f;
  float nav_qua2 = 0.0f;
  float nav_qua3 = 0.0f;
};

struct NAV FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NAVT NativeTableType;
  typedef NAVBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAV_STATUS = 4,
    VT_NAV_ROLL = 6,
    VT_NAV_PITCH = 8,
    VT_NAV_YAW = 10,
    VT_NAV_LAT = 12,
    VT_NAV_LON = 14,
    VT_NAV_ALT = 16,
    VT_NAV_QUA0 = 18,
    VT_NAV_QUA1 = 20,
    VT_NAV_QUA2 = 22,
    VT_NAV_QUA3 = 24
  };
  HJProtocol::NavStatus nav_status() const {
    return static_cast<HJProtocol::NavStatus>(GetField<int8_t>(VT_NAV_STATUS, 0));
  }
  float nav_roll() const {
    return GetField<float>(VT_NAV_ROLL, 0.0f);
  }
  float nav_pitch() const {
    return GetField<float>(VT_NAV_PITCH, 0.0f);
  }
  float nav_yaw() const {
    return GetField<float>(VT_NAV_YAW, 0.0f);
  }
  double nav_lat() const {
    return GetField<double>(VT_NAV_LAT, 0.0);
  }
  double nav_lon() const {
    return GetField<double>(VT_NAV_LON, 0.0);
  }
  float nav_alt() const {
    return GetField<float>(VT_NAV_ALT, 0.0f);
  }
  float nav_qua0() const {
    return GetField<float>(VT_NAV_QUA0, 0.0f);
  }
  float nav_qua1() const {
    return GetField<float>(VT_NAV_QUA1, 0.0f);
  }
  float nav_qua2() const {
    return GetField<float>(VT_NAV_QUA2, 0.0f);
  }
  float nav_qua3() const {
    return GetField<float>(VT_NAV_QUA3, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_NAV_STATUS, 1) &&
           VerifyField<float>(verifier, VT_NAV_ROLL, 4) &&
           VerifyField<float>(verifier, VT_NAV_PITCH, 4) &&
           VerifyField<float>(verifier, VT_NAV_YAW, 4) &&
           VerifyField<double>(verifier, VT_NAV_LAT, 8) &&
           VerifyField<double>(verifier, VT_NAV_LON, 8) &&
           VerifyField<float>(verifier, VT_NAV_ALT, 4) &&
           VerifyField<float>(verifier, VT_NAV_QUA0, 4) &&
           VerifyField<float>(verifier, VT_NAV_QUA1, 4) &&
           VerifyField<float>(verifier, VT_NAV_QUA2, 4) &&
           VerifyField<float>(verifier, VT_NAV_QUA3, 4) &&
           verifier.EndTable();
  }
  NAVT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NAVT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NAV> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NAVT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NAVBuilder {
  typedef NAV Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nav_status(HJProtocol::NavStatus nav_status) {
    fbb_.AddElement<int8_t>(NAV::VT_NAV_STATUS, static_cast<int8_t>(nav_status), 0);
  }
  void add_nav_roll(float nav_roll) {
    fbb_.AddElement<float>(NAV::VT_NAV_ROLL, nav_roll, 0.0f);
  }
  void add_nav_pitch(float nav_pitch) {
    fbb_.AddElement<float>(NAV::VT_NAV_PITCH, nav_pitch, 0.0f);
  }
  void add_nav_yaw(float nav_yaw) {
    fbb_.AddElement<float>(NAV::VT_NAV_YAW, nav_yaw, 0.0f);
  }
  void add_nav_lat(double nav_lat) {
    fbb_.AddElement<double>(NAV::VT_NAV_LAT, nav_lat, 0.0);
  }
  void add_nav_lon(double nav_lon) {
    fbb_.AddElement<double>(NAV::VT_NAV_LON, nav_lon, 0.0);
  }
  void add_nav_alt(float nav_alt) {
    fbb_.AddElement<float>(NAV::VT_NAV_ALT, nav_alt, 0.0f);
  }
  void add_nav_qua0(float nav_qua0) {
    fbb_.AddElement<float>(NAV::VT_NAV_QUA0, nav_qua0, 0.0f);
  }
  void add_nav_qua1(float nav_qua1) {
    fbb_.AddElement<float>(NAV::VT_NAV_QUA1, nav_qua1, 0.0f);
  }
  void add_nav_qua2(float nav_qua2) {
    fbb_.AddElement<float>(NAV::VT_NAV_QUA2, nav_qua2, 0.0f);
  }
  void add_nav_qua3(float nav_qua3) {
    fbb_.AddElement<float>(NAV::VT_NAV_QUA3, nav_qua3, 0.0f);
  }
  explicit NAVBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NAV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NAV>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NAV> CreateNAV(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    HJProtocol::NavStatus nav_status = HJProtocol::NavStatus::UNKNOWN,
    float nav_roll = 0.0f,
    float nav_pitch = 0.0f,
    float nav_yaw = 0.0f,
    double nav_lat = 0.0,
    double nav_lon = 0.0,
    float nav_alt = 0.0f,
    float nav_qua0 = 0.0f,
    float nav_qua1 = 0.0f,
    float nav_qua2 = 0.0f,
    float nav_qua3 = 0.0f) {
  NAVBuilder builder_(_fbb);
  builder_.add_nav_lon(nav_lon);
  builder_.add_nav_lat(nav_lat);
  builder_.add_nav_qua3(nav_qua3);
  builder_.add_nav_qua2(nav_qua2);
  builder_.add_nav_qua1(nav_qua1);
  builder_.add_nav_qua0(nav_qua0);
  builder_.add_nav_alt(nav_alt);
  builder_.add_nav_yaw(nav_yaw);
  builder_.add_nav_pitch(nav_pitch);
  builder_.add_nav_roll(nav_roll);
  builder_.add_nav_status(nav_status);
  return builder_.Finish();
}

::flatbuffers::Offset<NAV> CreateNAV(::flatbuffers::FlatBufferBuilder &_fbb, const NAVT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IMUT : public ::flatbuffers::NativeTable {
  typedef IMU TableType;
  float accx = 0.0f;
  float accy = 0.0f;
  float accz = 0.0f;
  float gyrx = 0.0f;
  float gyry = 0.0f;
  float gyrz = 0.0f;
};

struct IMU FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IMUT NativeTableType;
  typedef IMUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCX = 4,
    VT_ACCY = 6,
    VT_ACCZ = 8,
    VT_GYRX = 10,
    VT_GYRY = 12,
    VT_GYRZ = 14
  };
  float accx() const {
    return GetField<float>(VT_ACCX, 0.0f);
  }
  float accy() const {
    return GetField<float>(VT_ACCY, 0.0f);
  }
  float accz() const {
    return GetField<float>(VT_ACCZ, 0.0f);
  }
  float gyrx() const {
    return GetField<float>(VT_GYRX, 0.0f);
  }
  float gyry() const {
    return GetField<float>(VT_GYRY, 0.0f);
  }
  float gyrz() const {
    return GetField<float>(VT_GYRZ, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ACCX, 4) &&
           VerifyField<float>(verifier, VT_ACCY, 4) &&
           VerifyField<float>(verifier, VT_ACCZ, 4) &&
           VerifyField<float>(verifier, VT_GYRX, 4) &&
           VerifyField<float>(verifier, VT_GYRY, 4) &&
           VerifyField<float>(verifier, VT_GYRZ, 4) &&
           verifier.EndTable();
  }
  IMUT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IMUT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IMU> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IMUT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IMUBuilder {
  typedef IMU Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_accx(float accx) {
    fbb_.AddElement<float>(IMU::VT_ACCX, accx, 0.0f);
  }
  void add_accy(float accy) {
    fbb_.AddElement<float>(IMU::VT_ACCY, accy, 0.0f);
  }
  void add_accz(float accz) {
    fbb_.AddElement<float>(IMU::VT_ACCZ, accz, 0.0f);
  }
  void add_gyrx(float gyrx) {
    fbb_.AddElement<float>(IMU::VT_GYRX, gyrx, 0.0f);
  }
  void add_gyry(float gyry) {
    fbb_.AddElement<float>(IMU::VT_GYRY, gyry, 0.0f);
  }
  void add_gyrz(float gyrz) {
    fbb_.AddElement<float>(IMU::VT_GYRZ, gyrz, 0.0f);
  }
  explicit IMUBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IMU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IMU>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IMU> CreateIMU(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float accx = 0.0f,
    float accy = 0.0f,
    float accz = 0.0f,
    float gyrx = 0.0f,
    float gyry = 0.0f,
    float gyrz = 0.0f) {
  IMUBuilder builder_(_fbb);
  builder_.add_gyrz(gyrz);
  builder_.add_gyry(gyry);
  builder_.add_gyrx(gyrx);
  builder_.add_accz(accz);
  builder_.add_accy(accy);
  builder_.add_accx(accx);
  return builder_.Finish();
}

::flatbuffers::Offset<IMU> CreateIMU(::flatbuffers::FlatBufferBuilder &_fbb, const IMUT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GPST : public ::flatbuffers::NativeTable {
  typedef GPS TableType;
  double lat = 0.0;
  double lon = 0.0;
  float alt = 0.0f;
  uint8_t sat = 0;
  uint8_t fix_status = 0;
  uint8_t fix_type = 0;
  uint64_t time = 0;
};

struct GPS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPST NativeTableType;
  typedef GPSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAT = 4,
    VT_LON = 6,
    VT_ALT = 8,
    VT_SAT = 10,
    VT_FIX_STATUS = 12,
    VT_FIX_TYPE = 14,
    VT_TIME = 16
  };
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  float alt() const {
    return GetField<float>(VT_ALT, 0.0f);
  }
  uint8_t sat() const {
    return GetField<uint8_t>(VT_SAT, 0);
  }
  uint8_t fix_status() const {
    return GetField<uint8_t>(VT_FIX_STATUS, 0);
  }
  uint8_t fix_type() const {
    return GetField<uint8_t>(VT_FIX_TYPE, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LAT, 8) &&
           VerifyField<double>(verifier, VT_LON, 8) &&
           VerifyField<float>(verifier, VT_ALT, 4) &&
           VerifyField<uint8_t>(verifier, VT_SAT, 1) &&
           VerifyField<uint8_t>(verifier, VT_FIX_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_FIX_TYPE, 1) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           verifier.EndTable();
  }
  GPST *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GPST *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GPS> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GPST* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GPSBuilder {
  typedef GPS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lat(double lat) {
    fbb_.AddElement<double>(GPS::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(GPS::VT_LON, lon, 0.0);
  }
  void add_alt(float alt) {
    fbb_.AddElement<float>(GPS::VT_ALT, alt, 0.0f);
  }
  void add_sat(uint8_t sat) {
    fbb_.AddElement<uint8_t>(GPS::VT_SAT, sat, 0);
  }
  void add_fix_status(uint8_t fix_status) {
    fbb_.AddElement<uint8_t>(GPS::VT_FIX_STATUS, fix_status, 0);
  }
  void add_fix_type(uint8_t fix_type) {
    fbb_.AddElement<uint8_t>(GPS::VT_FIX_TYPE, fix_type, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(GPS::VT_TIME, time, 0);
  }
  explicit GPSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPS> CreateGPS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double lat = 0.0,
    double lon = 0.0,
    float alt = 0.0f,
    uint8_t sat = 0,
    uint8_t fix_status = 0,
    uint8_t fix_type = 0,
    uint64_t time = 0) {
  GPSBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_alt(alt);
  builder_.add_fix_type(fix_type);
  builder_.add_fix_status(fix_status);
  builder_.add_sat(sat);
  return builder_.Finish();
}

::flatbuffers::Offset<GPS> CreateGPS(::flatbuffers::FlatBufferBuilder &_fbb, const GPST *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TelemetryT : public ::flatbuffers::NativeTable {
  typedef Telemetry TableType;
  std::unique_ptr<HJProtocol::StateT> state{};
  std::unique_ptr<HJProtocol::NAVT> nav{};
  std::unique_ptr<HJProtocol::IMUT> imu{};
  std::unique_ptr<HJProtocol::GPST> gps{};
  std::vector<uint8_t> sv{};
  std::vector<float> pt{};
  std::vector<uint16_t> pt_raw{};
  std::vector<float> tc{};
  std::vector<uint16_t> tc_raw{};
  std::string config{};
  TelemetryT() = default;
  TelemetryT(const TelemetryT &o);
  TelemetryT(TelemetryT&&) FLATBUFFERS_NOEXCEPT = default;
  TelemetryT &operator=(TelemetryT o) FLATBUFFERS_NOEXCEPT;
};

struct Telemetry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TelemetryT NativeTableType;
  typedef TelemetryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_NAV = 6,
    VT_IMU = 8,
    VT_GPS = 10,
    VT_SV = 12,
    VT_PT = 14,
    VT_PT_RAW = 16,
    VT_TC = 18,
    VT_TC_RAW = 20,
    VT_CONFIG = 22
  };
  const HJProtocol::State *state() const {
    return GetPointer<const HJProtocol::State *>(VT_STATE);
  }
  const HJProtocol::NAV *nav() const {
    return GetPointer<const HJProtocol::NAV *>(VT_NAV);
  }
  const HJProtocol::IMU *imu() const {
    return GetPointer<const HJProtocol::IMU *>(VT_IMU);
  }
  const HJProtocol::GPS *gps() const {
    return GetPointer<const HJProtocol::GPS *>(VT_GPS);
  }
  const ::flatbuffers::Vector<uint8_t> *sv() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SV);
  }
  const ::flatbuffers::Vector<float> *pt() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_PT);
  }
  const ::flatbuffers::Vector<uint16_t> *pt_raw() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_PT_RAW);
  }
  const ::flatbuffers::Vector<float> *tc() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_TC);
  }
  const ::flatbuffers::Vector<uint16_t> *tc_raw() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_TC_RAW);
  }
  const ::flatbuffers::String *config() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyTable(state()) &&
           VerifyOffset(verifier, VT_NAV) &&
           verifier.VerifyTable(nav()) &&
           VerifyOffset(verifier, VT_IMU) &&
           verifier.VerifyTable(imu()) &&
           VerifyOffset(verifier, VT_GPS) &&
           verifier.VerifyTable(gps()) &&
           VerifyOffset(verifier, VT_SV) &&
           verifier.VerifyVector(sv()) &&
           VerifyOffset(verifier, VT_PT) &&
           verifier.VerifyVector(pt()) &&
           VerifyOffset(verifier, VT_PT_RAW) &&
           verifier.VerifyVector(pt_raw()) &&
           VerifyOffset(verifier, VT_TC) &&
           verifier.VerifyVector(tc()) &&
           VerifyOffset(verifier, VT_TC_RAW) &&
           verifier.VerifyVector(tc_raw()) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyString(config()) &&
           verifier.EndTable();
  }
  TelemetryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TelemetryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Telemetry> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TelemetryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TelemetryBuilder {
  typedef Telemetry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(::flatbuffers::Offset<HJProtocol::State> state) {
    fbb_.AddOffset(Telemetry::VT_STATE, state);
  }
  void add_nav(::flatbuffers::Offset<HJProtocol::NAV> nav) {
    fbb_.AddOffset(Telemetry::VT_NAV, nav);
  }
  void add_imu(::flatbuffers::Offset<HJProtocol::IMU> imu) {
    fbb_.AddOffset(Telemetry::VT_IMU, imu);
  }
  void add_gps(::flatbuffers::Offset<HJProtocol::GPS> gps) {
    fbb_.AddOffset(Telemetry::VT_GPS, gps);
  }
  void add_sv(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> sv) {
    fbb_.AddOffset(Telemetry::VT_SV, sv);
  }
  void add_pt(::flatbuffers::Offset<::flatbuffers::Vector<float>> pt) {
    fbb_.AddOffset(Telemetry::VT_PT, pt);
  }
  void add_pt_raw(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> pt_raw) {
    fbb_.AddOffset(Telemetry::VT_PT_RAW, pt_raw);
  }
  void add_tc(::flatbuffers::Offset<::flatbuffers::Vector<float>> tc) {
    fbb_.AddOffset(Telemetry::VT_TC, tc);
  }
  void add_tc_raw(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> tc_raw) {
    fbb_.AddOffset(Telemetry::VT_TC_RAW, tc_raw);
  }
  void add_config(::flatbuffers::Offset<::flatbuffers::String> config) {
    fbb_.AddOffset(Telemetry::VT_CONFIG, config);
  }
  explicit TelemetryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Telemetry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Telemetry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Telemetry> CreateTelemetry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<HJProtocol::State> state = 0,
    ::flatbuffers::Offset<HJProtocol::NAV> nav = 0,
    ::flatbuffers::Offset<HJProtocol::IMU> imu = 0,
    ::flatbuffers::Offset<HJProtocol::GPS> gps = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> sv = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> pt = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> pt_raw = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> tc = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> tc_raw = 0,
    ::flatbuffers::Offset<::flatbuffers::String> config = 0) {
  TelemetryBuilder builder_(_fbb);
  builder_.add_config(config);
  builder_.add_tc_raw(tc_raw);
  builder_.add_tc(tc);
  builder_.add_pt_raw(pt_raw);
  builder_.add_pt(pt);
  builder_.add_sv(sv);
  builder_.add_gps(gps);
  builder_.add_imu(imu);
  builder_.add_nav(nav);
  builder_.add_state(state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Telemetry> CreateTelemetryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<HJProtocol::State> state = 0,
    ::flatbuffers::Offset<HJProtocol::NAV> nav = 0,
    ::flatbuffers::Offset<HJProtocol::IMU> imu = 0,
    ::flatbuffers::Offset<HJProtocol::GPS> gps = 0,
    const std::vector<uint8_t> *sv = nullptr,
    const std::vector<float> *pt = nullptr,
    const std::vector<uint16_t> *pt_raw = nullptr,
    const std::vector<float> *tc = nullptr,
    const std::vector<uint16_t> *tc_raw = nullptr,
    const char *config = nullptr) {
  auto sv__ = sv ? _fbb.CreateVector<uint8_t>(*sv) : 0;
  auto pt__ = pt ? _fbb.CreateVector<float>(*pt) : 0;
  auto pt_raw__ = pt_raw ? _fbb.CreateVector<uint16_t>(*pt_raw) : 0;
  auto tc__ = tc ? _fbb.CreateVector<float>(*tc) : 0;
  auto tc_raw__ = tc_raw ? _fbb.CreateVector<uint16_t>(*tc_raw) : 0;
  auto config__ = config ? _fbb.CreateString(config) : 0;
  return HJProtocol::CreateTelemetry(
      _fbb,
      state,
      nav,
      imu,
      gps,
      sv__,
      pt__,
      pt_raw__,
      tc__,
      tc_raw__,
      config__);
}

::flatbuffers::Offset<Telemetry> CreateTelemetry(::flatbuffers::FlatBufferBuilder &_fbb, const TelemetryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline StateT *State::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StateT>(new StateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void State::UnPackTo(StateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = boot_time(); _o->boot_time = _e; }
  { auto _e = mode_time(); _o->mode_time = _e; }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = countdown(); _o->countdown = _e; }
  { auto _e = warn_code(); _o->warn_code = _e; }
  { auto _e = error_code(); _o->error_code = _e; }
  { auto _e = voltage(); _o->voltage = _e; }
  { auto _e = current(); _o->current = _e; }
}

inline ::flatbuffers::Offset<State> State::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<State> CreateState(::flatbuffers::FlatBufferBuilder &_fbb, const StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _boot_time = _o->boot_time;
  auto _mode_time = _o->mode_time;
  auto _mode = _o->mode;
  auto _countdown = _o->countdown;
  auto _warn_code = _o->warn_code;
  auto _error_code = _o->error_code;
  auto _voltage = _o->voltage;
  auto _current = _o->current;
  return HJProtocol::CreateState(
      _fbb,
      _boot_time,
      _mode_time,
      _mode,
      _countdown,
      _warn_code,
      _error_code,
      _voltage,
      _current);
}

inline NAVT *NAV::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NAVT>(new NAVT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NAV::UnPackTo(NAVT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nav_status(); _o->nav_status = _e; }
  { auto _e = nav_roll(); _o->nav_roll = _e; }
  { auto _e = nav_pitch(); _o->nav_pitch = _e; }
  { auto _e = nav_yaw(); _o->nav_yaw = _e; }
  { auto _e = nav_lat(); _o->nav_lat = _e; }
  { auto _e = nav_lon(); _o->nav_lon = _e; }
  { auto _e = nav_alt(); _o->nav_alt = _e; }
  { auto _e = nav_qua0(); _o->nav_qua0 = _e; }
  { auto _e = nav_qua1(); _o->nav_qua1 = _e; }
  { auto _e = nav_qua2(); _o->nav_qua2 = _e; }
  { auto _e = nav_qua3(); _o->nav_qua3 = _e; }
}

inline ::flatbuffers::Offset<NAV> NAV::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NAVT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNAV(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NAV> CreateNAV(::flatbuffers::FlatBufferBuilder &_fbb, const NAVT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NAVT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nav_status = _o->nav_status;
  auto _nav_roll = _o->nav_roll;
  auto _nav_pitch = _o->nav_pitch;
  auto _nav_yaw = _o->nav_yaw;
  auto _nav_lat = _o->nav_lat;
  auto _nav_lon = _o->nav_lon;
  auto _nav_alt = _o->nav_alt;
  auto _nav_qua0 = _o->nav_qua0;
  auto _nav_qua1 = _o->nav_qua1;
  auto _nav_qua2 = _o->nav_qua2;
  auto _nav_qua3 = _o->nav_qua3;
  return HJProtocol::CreateNAV(
      _fbb,
      _nav_status,
      _nav_roll,
      _nav_pitch,
      _nav_yaw,
      _nav_lat,
      _nav_lon,
      _nav_alt,
      _nav_qua0,
      _nav_qua1,
      _nav_qua2,
      _nav_qua3);
}

inline IMUT *IMU::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IMUT>(new IMUT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IMU::UnPackTo(IMUT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = accx(); _o->accx = _e; }
  { auto _e = accy(); _o->accy = _e; }
  { auto _e = accz(); _o->accz = _e; }
  { auto _e = gyrx(); _o->gyrx = _e; }
  { auto _e = gyry(); _o->gyry = _e; }
  { auto _e = gyrz(); _o->gyrz = _e; }
}

inline ::flatbuffers::Offset<IMU> IMU::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IMUT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIMU(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IMU> CreateIMU(::flatbuffers::FlatBufferBuilder &_fbb, const IMUT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IMUT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _accx = _o->accx;
  auto _accy = _o->accy;
  auto _accz = _o->accz;
  auto _gyrx = _o->gyrx;
  auto _gyry = _o->gyry;
  auto _gyrz = _o->gyrz;
  return HJProtocol::CreateIMU(
      _fbb,
      _accx,
      _accy,
      _accz,
      _gyrx,
      _gyry,
      _gyrz);
}

inline GPST *GPS::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GPST>(new GPST());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GPS::UnPackTo(GPST *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lat(); _o->lat = _e; }
  { auto _e = lon(); _o->lon = _e; }
  { auto _e = alt(); _o->alt = _e; }
  { auto _e = sat(); _o->sat = _e; }
  { auto _e = fix_status(); _o->fix_status = _e; }
  { auto _e = fix_type(); _o->fix_type = _e; }
  { auto _e = time(); _o->time = _e; }
}

inline ::flatbuffers::Offset<GPS> GPS::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GPST* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGPS(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GPS> CreateGPS(::flatbuffers::FlatBufferBuilder &_fbb, const GPST *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GPST* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lat = _o->lat;
  auto _lon = _o->lon;
  auto _alt = _o->alt;
  auto _sat = _o->sat;
  auto _fix_status = _o->fix_status;
  auto _fix_type = _o->fix_type;
  auto _time = _o->time;
  return HJProtocol::CreateGPS(
      _fbb,
      _lat,
      _lon,
      _alt,
      _sat,
      _fix_status,
      _fix_type,
      _time);
}

inline TelemetryT::TelemetryT(const TelemetryT &o)
      : state((o.state) ? new HJProtocol::StateT(*o.state) : nullptr),
        nav((o.nav) ? new HJProtocol::NAVT(*o.nav) : nullptr),
        imu((o.imu) ? new HJProtocol::IMUT(*o.imu) : nullptr),
        gps((o.gps) ? new HJProtocol::GPST(*o.gps) : nullptr),
        sv(o.sv),
        pt(o.pt),
        pt_raw(o.pt_raw),
        tc(o.tc),
        tc_raw(o.tc_raw),
        config(o.config) {
}

inline TelemetryT &TelemetryT::operator=(TelemetryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(state, o.state);
  std::swap(nav, o.nav);
  std::swap(imu, o.imu);
  std::swap(gps, o.gps);
  std::swap(sv, o.sv);
  std::swap(pt, o.pt);
  std::swap(pt_raw, o.pt_raw);
  std::swap(tc, o.tc);
  std::swap(tc_raw, o.tc_raw);
  std::swap(config, o.config);
  return *this;
}

inline TelemetryT *Telemetry::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TelemetryT>(new TelemetryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Telemetry::UnPackTo(TelemetryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = state(); if (_e) { if(_o->state) { _e->UnPackTo(_o->state.get(), _resolver); } else { _o->state = std::unique_ptr<HJProtocol::StateT>(_e->UnPack(_resolver)); } } else if (_o->state) { _o->state.reset(); } }
  { auto _e = nav(); if (_e) { if(_o->nav) { _e->UnPackTo(_o->nav.get(), _resolver); } else { _o->nav = std::unique_ptr<HJProtocol::NAVT>(_e->UnPack(_resolver)); } } else if (_o->nav) { _o->nav.reset(); } }
  { auto _e = imu(); if (_e) { if(_o->imu) { _e->UnPackTo(_o->imu.get(), _resolver); } else { _o->imu = std::unique_ptr<HJProtocol::IMUT>(_e->UnPack(_resolver)); } } else if (_o->imu) { _o->imu.reset(); } }
  { auto _e = gps(); if (_e) { if(_o->gps) { _e->UnPackTo(_o->gps.get(), _resolver); } else { _o->gps = std::unique_ptr<HJProtocol::GPST>(_e->UnPack(_resolver)); } } else if (_o->gps) { _o->gps.reset(); } }
  { auto _e = sv(); if (_e) { _o->sv.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->sv.begin()); } }
  { auto _e = pt(); if (_e) { _o->pt.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pt[_i] = _e->Get(_i); } } else { _o->pt.resize(0); } }
  { auto _e = pt_raw(); if (_e) { _o->pt_raw.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pt_raw[_i] = _e->Get(_i); } } else { _o->pt_raw.resize(0); } }
  { auto _e = tc(); if (_e) { _o->tc.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tc[_i] = _e->Get(_i); } } else { _o->tc.resize(0); } }
  { auto _e = tc_raw(); if (_e) { _o->tc_raw.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tc_raw[_i] = _e->Get(_i); } } else { _o->tc_raw.resize(0); } }
  { auto _e = config(); if (_e) _o->config = _e->str(); }
}

inline ::flatbuffers::Offset<Telemetry> Telemetry::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TelemetryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTelemetry(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Telemetry> CreateTelemetry(::flatbuffers::FlatBufferBuilder &_fbb, const TelemetryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TelemetryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _state = _o->state ? CreateState(_fbb, _o->state.get(), _rehasher) : 0;
  auto _nav = _o->nav ? CreateNAV(_fbb, _o->nav.get(), _rehasher) : 0;
  auto _imu = _o->imu ? CreateIMU(_fbb, _o->imu.get(), _rehasher) : 0;
  auto _gps = _o->gps ? CreateGPS(_fbb, _o->gps.get(), _rehasher) : 0;
  auto _sv = _o->sv.size() ? _fbb.CreateVector(_o->sv) : 0;
  auto _pt = _o->pt.size() ? _fbb.CreateVector(_o->pt) : 0;
  auto _pt_raw = _o->pt_raw.size() ? _fbb.CreateVector(_o->pt_raw) : 0;
  auto _tc = _o->tc.size() ? _fbb.CreateVector(_o->tc) : 0;
  auto _tc_raw = _o->tc_raw.size() ? _fbb.CreateVector(_o->tc_raw) : 0;
  auto _config = _o->config.empty() ? 0 : _fbb.CreateString(_o->config);
  return HJProtocol::CreateTelemetry(
      _fbb,
      _state,
      _nav,
      _imu,
      _gps,
      _sv,
      _pt,
      _pt_raw,
      _tc,
      _tc_raw,
      _config);
}

inline const HJProtocol::Telemetry *GetTelemetry(const void *buf) {
  return ::flatbuffers::GetRoot<HJProtocol::Telemetry>(buf);
}

inline const HJProtocol::Telemetry *GetSizePrefixedTelemetry(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<HJProtocol::Telemetry>(buf);
}

inline const char *TelemetryIdentifier() {
  return "HJTM";
}

inline bool TelemetryBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TelemetryIdentifier());
}

inline bool SizePrefixedTelemetryBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TelemetryIdentifier(), true);
}

inline bool VerifyTelemetryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<HJProtocol::Telemetry>(TelemetryIdentifier());
}

inline bool VerifySizePrefixedTelemetryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<HJProtocol::Telemetry>(TelemetryIdentifier());
}

inline void FinishTelemetryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HJProtocol::Telemetry> root) {
  fbb.Finish(root, TelemetryIdentifier());
}

inline void FinishSizePrefixedTelemetryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HJProtocol::Telemetry> root) {
  fbb.FinishSizePrefixed(root, TelemetryIdentifier());
}

inline std::unique_ptr<HJProtocol::TelemetryT> UnPackTelemetry(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<HJProtocol::TelemetryT>(GetTelemetry(buf)->UnPack(res));
}

inline std::unique_ptr<HJProtocol::TelemetryT> UnPackSizePrefixedTelemetry(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<HJProtocol::TelemetryT>(GetSizePrefixedTelemetry(buf)->UnPack(res));
}

}  // namespace HJProtocol

#endif  // FLATBUFFERS_GENERATED_TELEMETRY_HJPROTOCOL_H_
